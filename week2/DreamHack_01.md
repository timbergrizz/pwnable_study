이번엔 드림핵의 기초 프로그래머들을 위한 강의이다. 시작해보자
사례와 관련한 내용들은 우선 다 생략한다. 궁금하면 위키피디아를 검색해보도록 하자.

우선 해킹의 정의에 대해서 얘기해보자. 해킹은 각종 정보 체계에서 주어진 권한 이상의 권한을 얻거나 의도하지 않은 동작을 일으키게 하는 것이다.

해킹이 처음부터 이런 의미를 가지고 있던것은 아니다. 우선 유래에 대해 이야기를 좀 해보자. 해킹의 어원은 Hack이다. 특정 문제를 풀거나 비효율적인 시스템을 개선하는 해결책이라는 의미이다. 이러한 해결책을 제시하는 프로그래머를 해커라고 불렀고, 컴퓨터에 빠진 전문가들을 뜻하기도 했다.

그러나 시간이 흐르며 창의적인 해결책들이 악의적인 의도로 만들어지기 시작했다. 존 드래퍼의 예시가 초기의 대표 사례라고 할 수 있다.

1980년대에 접어들며 PC가 등장했고, 컴퓨터 시스템이 대중화되었다. 따라서 공격의 대상이 컴퓨터와 컴퓨터 시스템이 되었다. 이 시기의 대표적인 사례는 모리스 웜이다. 이후로 90년대 웹과 인터넷이 발명되면서 컴퓨터가 점점 우리 삶에 깊이 관여하게 되었고 민감한 정보들도 컴퓨터를 통해 관리되기 시작했다. 그러나 컴퓨터와 같이 해킹 기술도 발전하고, 피해의 규모도 커졌다.
기술이 발전하며 컴퓨터 시스템은 복잡해졌고, 이들은 해킹의 대상이 되었다. 따라서 무엇을 공격 대상으로 삼느냐에 따라 해킹 기술을 나눌 수 있다. 웹 사이트를 공격하는 웹해킹, 네트워크를 공격하는 네트워킹 해킹, 프로그램의 약점을 공격하는 시스템 해킹, 즉 지금 공부하는 포너블 등이 있다.

아까 말했듯이 컴퓨터와 소프트웨어는 우리의 삶에 충분히 많이 사용되고 있다. 해킹의 방향과 타겟에 따라 상상 할 수 없을 정도로 큰 피해를 입힐수도 있다.

그러면 어떤 식으로 소프트웨어의 약점을 찾아내고 공격자가 얻어내고자 하는 것을 찾는지 알아보자.

해킹은 논리와 규칙을 따르며, 그 원리를 살펴본다면 누구나 이해할 수 있을 정도로 단순하다. 해킹은 규칙을 창조적으로 활용해 의도치 않은 결과를 얻어내는 행위일 뿐이다.

해킹의 원리에 대한 이야기를 해보자. 프로그램은 사람이 아니다. 사람은 의도에 벗어나는 질문을 알아서 예외 처리 할 수 있겠지만, 프로그램은 아니다. 프로그램은 구현대로만 동작하기 때문에 프로그래머가 이러한 예외 처리들을 해주어야 한다. 영리한 해커는 프로그램의 규칙을 악용해 자신이 원하는 바를 달성할 것이다.

프로그램이 의도치 않은 동작을 수행하게 되는 문제를 소프트웨어 버그라고 한다. 프로그램을 개발하거나 사용할 때 항상 이러한 것들을 만나게 될것이다. 버그 중에서는 보안을 심각하게 위협하는 버그들도 있을 수 있다.

소프트웨어 취약점은 공격자가 주어진 권한 이상의 권한을 획득하거나 프로그래머가 의도치 않은 동작을 수행하도록 하는 소프트웨어 버글르 의미한다. 공격자는 소프트웨어 취약점을 첮어 원하는 것을 달성하려 하고, 보안 전문가는 취약점을 패치, 제거해 프로그램을 보호하려 한다. 그러나 시스템에는 미처 발견하지 못한 취약점들이 있을 수 있고, 단 하나의 취약점으로도 공격자는 소프트웨어를 공격 할 수 있다.

소프트웨어의 취약점은 여러가지 요인으로 발생한다. 이 중 가장 대표적인 원인은 프로그래머의 실수이다. 프로그래밍할땐 직관적으로 보이지 만 그렇지 않은 코드들이 많이 있다. 이러한 코드는 지나치기 쉬운 실수를 유발하고, 때때로 심각한 보안 취약점으로 연결되게 된다. 

예시를 하나 들어보자. 4부터 12까지의 숫자를 저장하기 위해서는 크기 9의 배열이 필요하다. 그러나 얼핏 8개라고 생각할 수 있다. 간단하고, 충분히 핢나한 실수이다. 그러나 이 실수로 인해 공격자는 시스템을 장악할 수도 있다.

또한 취약점은 개발자의 잘못된 가정으로도 발생한다. 항상 올바른 입력이 들어올 것이라는 잘못된 믿음이다. 또다시 간단한 에시를 설정해보자, 생년월일과 현재 날짜를 입력받아 태어난지 며칠이 지났는지 계산하는 프로그램을 만든다고 하자. 여기서 숫자를 입력받을때 사용자의 입력값에 대한 검증이 존재하지 않는다면, 사용자가 문자열을 입력했을 때 소프트웨어 버그가 발생할 것이다. OpenSSL에서 이러한 취약점이 발생해 심각한 문제를 일으켰던 적이 있었다.

취약점에 대한 얘기로 넘어가보자.
익스플로잇은 사전적으로는 악용이라는 뜻을 갖고 있고, 취약점을 이용해 공격자가 의도한 동작을 수행하게 하는 코드, 또는 이러한 공격행위를 의미한다.

소프트웨어 버그는 4가지 종류로 나타낼 수 있다. 이를 나누는 기준을 취약점을 통해 공격자의 의도를 달성하는 데 어느 정도 도움을 주는지이다.

먼저 프로그래머가 의도하지 않은 동작을 수행하게 하는 소프트웨어 버그(bug)가 최상위고,  버그중 보안에 영향을 미칠 수 있는 버그를 소프트웨어 취약점(Vurnerability)라고 한다. 취약점중 이를 이용해 공격자가 의도한 동작을 수행하도록 하는 버그르 익스플로잇 가능한 취약점(Exploitable Vulnerability)라 하고, 이 중 익스플로잇의 가능성이 높아 안정적인 익스플로잇이 가능한 취약점을 안정적으로 익스플로잇 가능한 취약점(Reliably Exploitable Vulnerability)라고 한다.

익스플로잇 확률은 위험성을 평가하는 중요한 요소 중 하나인데,  익스플로잇이 가능하다고 해서 항상 안정적으로 성공할 수 있는것은 아니다. 보한 취약점에서 익스플로잇 확률은 위험성을 평가하는 중요 요소중 하나인데, 익스플로잇 확률이 높을수록 무기화되어 사용하기 유용하고, 공격 탐지 확률이 줄어들기 때문이다. 따라서 익스플로잇 확률이 높을수록 위험한 공격이 된다.

모든 소프트웨어 취약점은 소프트웨어와 공격자가 상호작용하는 곳, 즉 사용자의 입력에서 출발한다. 이렇게 공격자와 소프트웨어의 상호 작용을 하는 곳을 공격 벡터(Attack Vector)라 하고, 이러한 공격 벡터들의 집합을 Attack surface라고 한다.
공격자는 입력을 통해 프로그램과 상호 작용할 수 있고, 이를 프로그램에 전달할 수 있다. 입력을받는 부분에서 보안 취약점이 발생하면, 이는 공격자가 접근해 악용할 수 있기 때문에 보안 취약점이라 할 수 있다 따라서, 프로그래머는 사용자에게 입력 받는 부분을 철저히 검증해야 한다. 프로그래머가 사용자의 입력을 받는 부분에서 실수한다면 예상치 못한 버그가 발생할 수 있고, 실수는 보안 취약점으로 이어질 수 있다..
그러나, 프로그램에 도달 불가능한 영역(unreachable code) 에 취약점이 있다고 하자. 해당 코드가 어디에서도 사용되지 않고 공격자가 이를 실행할 수 없다면 이를 보안 취약점이라고 할 수 없다. 그렇다고 해서 존재해도 된다는 의미는 아니다.

취약점의 종류는 크게 두가지로 나눌 수 있다. C, C++같은 메모리를 직접 조작하는 고전 언어에서 메모리를 조작해 메모리 커럽션 취약점과 메모리를 조작할 필요 없이 공격할 수 있는 로지컬 취약점이다. 우선 메모리 커럽션에 대해 알아보자.

메머리 커럽션 취약점의 종류로는, Buffer Overflow, Out-Of-Boundary, Off-by-one, Format String Bug, Double Free / Use-After-Free 등이 있다

Buffer Overflow는 메모리 커럽션 중 가장 대표적인 취약점이다. 프로그래머가 할당한 크기의 버퍼보다 더 큰 데이터를 입력받아 메모리의 다른 영역을 오염시킬 수 있는 취약점이다. 발표된지 30년이 지나도 사용되는 취약점이다.

Out-Of-Boundary(OOB)
OOB 취약점은 버퍼의  길이 범위를 벗어나는 곳에 데이터에 접근할 수 있는 취약점이다. 버퍼 오버플로우와 마찬가지로 매우 강력한 취약점으로, 대규모 최신 소프트웨어에서도 자주 발견되는 취약점이다.

Off-by-one
Off-by-one은 경계 검사에서 하나 더 많은 값을 쓸 수 있을 때 발생하는 취약점이다. 32바이트 크기 버퍼에 인덱스 32로 접근하는 것 같은 경우이다. 반복문을 순회할 때 잘못된 비교 연산자를 사용하거나 인덱스가 0부터 시작하는 것을 고려하지 않았을때 발생한다.

Format String Bug(FSB)
FSB는 printf나 sprintf와 같은 함수에서 포맷 스트림 문자열을 올바르게 사용하지 못해 발생한다. 매우 강력한 취약점이지만, 최신 컴파일러에서는 여러가지 방법으로 이를 방어하고 있어 최근엔 잘 발생하지 않는다.

Double Free / Use-After-Free
Double Free와 Use-After-Free는 동적 할당된 메모리를 정확히 관리하지 못했을 때 발생한다. 이미 해제된 메모리를 다시 해제하려고 할때 Double Free, 해제된 메모리를 접근해 사용하려고 하는 것을 Use-After-Free라고 한다.

이제 로지컬 버그에 대해 좀 알아보자. 로지컬 버그는 메모리 구조를 이용해 공격하는 것이 아니다. 따라서 메모리 커럽션보다 익스플로잇 작성이 간단하다.
로지컬 버그의 종류로는 Command Injection, Race Condition, Path Traversal 등이 있다.

Command Injection
Command Injection은 사용자의 입력을 셸에 전달해 실행할 때 정확한 검사를 실행하지 않아 발생하는 취약점이다. 공격자가 원하는 명력을 실행할 수 있고, 익스플로잇이 어렵지 않아 매우 강한 취약점이다

Race Condition
보안 취약점으로서의 Race Condition은 여러 스레드나 프로세스의 자원 관리를 정확히 수행하지 못해 데이터가 오염되는 취약점이다. 발생 원인, 공격 방법에 따라 메모리 커럽션 취약점, 로지컬 취약점으로 각각 분류될 수 있다.

Path Traversal
Path Traversal은 프로그래머가 가정한 디렉토리를 벗어나 외부에 존재하는 파일에 접근할 수 있는 취약점이다. 이는 주로 소스코드에서 경로 문자를 검사하지 않아 발생한다.

초기의 소프트웨어들은 이렇나 악의적 공격에 대한 대책이 전혀 준비되어있지 않아 취약점만 존재한다면 쉽게 공격당했다. 프로그래머가 취약점을 없는 프로그램을 작성하기를 바라는것은 근본적인 해결책이 아니다. 자연스럽게 프로그램의 취약점 존재 여부와는 무관하게 보호하는 방법을 고안하게 되었고, 이렇게 미티게이션이 등장했다

미티게이션은 취약점의 공격을 어렵게 한다. 예를 들면, 스택 버퍼 오버플로우를 방지하는 미티게이션인 Stack Smashing Protector가 있다. 그러나 방패가 강해지면 창도 강해지고, 해커들이 미티게이션을 우회하기 위한 새로운 공격 기법들을 고안했다. 새로운 공격기법들이 생기면, 이를 막기 위한 새로운 미티게이션이 등장되고, 창과 방패의 대결은 끝없이 이어지게 된다.

취약점이 아예 존재하지 않는 프로그램은 거의 없지만, 미티게이션이 어떤 상황에서든 프로그램을 보호하는것은 아니기에 취약점 없는 프로그램을 만드려는 노력이 가장 중요하다.