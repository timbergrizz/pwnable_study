오버플로우에 조금 더 깊이 들어가보자. 옛날 옛적부터 내려오던 달고나 자료로 공부를 해보자. 이건 나 중학교때도 있던것 같은데 진짜 무슨 팔만대장경인가.

우선 이렇게 오래된 공격 기법인 버퍼 오버플로우를 왜 배우는지 생각해보자. 우선 제일 결정적인 이유는, 아직도 취약한 프로그램들이 만들어지고 있기 때문이다. 오래되었어도 C와 C++은 가장 많이 사용하는 언어 중 하나고, 데이터에 대한 검증이 제대로 이루어지지 않으면 취약점이 발생할 수 있게 된다. 그리고 오버플로우 공격 기법을 다시 짚어보며 원리를 이해하면 근래에 발표되는 문서를 이해하는데 큰 도움이 될 것이다.

버퍼 오버플로우 공격 기법을 이해하기 위해서는 컴퓨터에서 이루어지는 프로세스의 구조, 자료 저장 방식, 함수 호출 과정 / 리턴 과정, 함수 실행 과정에 대한 이해가 필요하다.

8086, 즉 x86 시스템의 기본 메모리 구조부터 알아보자. 기본적으로 낮은 주소에 상주하는 커널과 그 위로 존재화는 사용 가능한 공간이 있다. 시스템이 초기화되면, 시스템은 커널을 메모리에 적재시키고, 가용 메모리 영역을 확인하게 된다. 시스템은 운영에 필요한 기본적인 명령어 집합을 커널에서 찾기 때문에, 커널이 가장 낮은 주소에 상주하게 된다 커널은 기본적으로 64KB 영역에 자리잡지만, 오늘날의 운영 체제는 이를 확장해 더 큰 영역을 사용한다.

32비트 시스템에서는 cpu가 한번에 32바이트의 데이터를 처리할 수 있으므로 메모리 영역에 주소를 할당할 수 있는 범위가 0 ~ 2^32-1 이다. (64비트에서는 2^64-1까지)

이제 하나의 프로그램이 실행되는 메모리 구조를 알아보자. 하나의 프로세스를 실행시키면 이 프로세스는 segment라는 단위로 묶여 가용 메모리 영역에 저장된다. 오늘날의 시스템은 멀티 태스킹이 가능해, 메모리에는 여러 개의 프로세스가 한번에 저장 될 수 있고, 병렬적으로 작업을 수행하게 된다. 따라서 가용 메모리 영역에는 여러개의 segment들이 저장될 수 있다. segment는 하나의 프로세스를 묶은 단위로 실행 시점에 어느 위치에 저장될 지가 결정된다. 시스템에는 최대 16,383개의 segment가 저장될 수 있고 하나의 segment에는 2^32byte의 크기를 가질 수 있다. 

segment는 3개의 구조로 나눠진다. code segment, data segment, stack segment로 나누어지게 된다.
code segment에는 시스템이 인식하는 명령어(instruction)들이 들어 있다. 컴파일러가 만들어 낸 기계어 코드이다.
instruction들이 명령을 수행하면서 분기, 점프, 시스템 호출 등을 수행하는데, 분기와 점프에서 메모리의 특정 위치에 있는 명령을 지정해 주어야 한다.하지만 segment는 메모리 상에 어떤 위치에 저장될 지 컴파일 과정에서 알 수 없기 때문에 정확한 주소를 지정할 수 없다.
따라서 segment에서는 논리적 주소(logical address)를 사용한다. 논리적 주소는 메모리 상의 실제 주소와 연결된다.  즉 segment는 segment selector에 의해 자신의 시작 위치(offset)를 찾을 수 있고, 자신의 시작 위치로부터의 논리적 주소를 통해 명령을 수행할지를 결정하게 되는 것이다. 실제 메모리 주소는 offset + logical addresss라고 할 수 있다. segment가 어느 위치에 있더라도 segment selector가 segment의 offset을 알아내어 해당 instruction의 정확한 위치를 알아낼 수 있다.

Data segment에는 프로그램이 실행시 사용되는 데이터인 전역 변수들이 들어간다. 즉, 프로그램 내에서 전역 변수를 선언하면 그 변수가 data segment에 자리잡게 된다. Data segment는 4개로 나눠지게 되는데, 이는 현재 모듈의 data segment, 상위 레벨로부터 상속받은 데이터 모듈, 동적 생성 데이터, 다른 프로그램과 공유하는 공유 데이터 부분이다.

Stack segment는 현재 수행되고 있는 handler, task, program이 저장하는 데이터 영역이다. 지역 변수가 이 stack segment에 자리잡게 되고, 따라서 우리가 사용하는 버퍼가 이 stack segment에 자리잡게 된다. 또 프로그램이 사용하는 multiple stack을 생성할 수 있고 각 stack들 간 switch가 가능하다.
스택은 처음 생성될 때 필요한 크기만큼 만들어지고, 프로세스의 명령에 의해 데이터를 저장하는 과정을 거치는데, stack pointer라고 하는 레지스터가 스택의 꼭데기를 가리키고 있다. 스택에 데이터를 저장하고 읽는 과정은 push와 pop instruction에 의해 수행된다. 
스택은 후입선출의 과정으로 데이터를 가져온다. 새로운 데이터는 push를 통해 맨 위로 올리고, 맨 위부터 pop을 통해 가져온다.

지금까지 segment의 구조를 알아보았다. 그럼 이제 프로세스를 cpu에 적재시키고, 흩어져있는 명령어 집합과 데이터들을 적절하게 선택하고 읽고 저장하기 위한 저장 공간인 레지스터에 대해 알아보자. 레지스터는 cpu가 RW해야 하는 데이터들이므로 cpu 내부의 메모리를 이용한다

레지스터는 목적에 따라 범용 레지스터(General-Purpose Register), 세그먼트 레지스터(Segment Register), 플래그 레지스터(Program status and control register), 그리고 인스 트럭션 포인터 (instruction pointer)로 구성된다.  

범용 레지스터는 논리 연선, 수리 연산에 사용되는 피연산자, 주소를 계산하는데 사용되는 피연산자, 그리고 메모리 포인터가 저장된다. 그리고 범용 레지스터는 프로그래머가 임의로 조작할 수 있게 허용되어 있다. 4개의 32bit 변수라고 생각하면 된다. 16비트 시절 각 레지스터를 AX, BX, 등으로 불렀지만 32비트로 전환되면서 Extended가 이름에 붙어 EAX등으로 부른다. 각 레지스터는 필요에 따라 아무렇게나 사용해도 되지만, 이름을 보고 목적에 따라 사용하는 것이 좋다. 컴파일러도 이런 목적에 맞춰 사용한다.

세그먼트 레지스터는 code segment, data segment, stack segment를 가리키는 주소가 들어있다. 정확히, 프로세스의 특정 세그먼트를 가리키는 포인터 역할을 한다. CS 레지스터는 code segment를 DS, ES, FS, GS 레지스터는 data segment를, SS 레지스터는 stack segment를 가리킨다. 이렇게 세그먼트 레지스터가 가리키는 위치를 바탕으로 우리가 원하는 segment 내의 특정 데이터, 명령어들을 정확히 읽을 수 있게 된다.

플래그 레지스터는 프로그램의 현재 상태나 조건 등을 검사하는데 사용되는 플래그들이 있는 레지스터이다. 컨트롤 플래그 레지스터는 상태 플래그, 컨트롤 플래그, 시스템 플래그들의 집합이다. 시스템이 리셋되면 이 레지스터는 0x00000002의 값을 가진다. 1, 3, 5, 16, 22~31번 비트는 예약되어 있어 소프트웨어에 의해 조작할 수 없다.
플래그의 종류별로 나눠진 플래그는 한번 읽어보자. 큰 이해는 힘들수도 있다.

인스트럭션 포인터는 다음 수행해야 하는 명령이 있는 메모리 상의 주소, 즉 현재 code segment의 offset값이 들어가 있어, 하나의 명령어 범위에서 선형 명령 집합의 다음 위치리를 가리킬 수 있다. 뿐만 아니라 여러가지 instruction이 있는 주소값을 가진다. EIP 레지스터는 소프트웨어가 바로 엑세스 할 수 없고, control-transfer instruction 이나 interrupt와 exception에 의해 제어된다. EIP 레지스터를 읽으려면 CALL instruction을 수행하고 Procedure Stack 으로부터 리턴하는 instruction의 address를 읽는 것이다. Procedure stack의 return instruction pointer의 값을 수정하고 return instruction(RET, IRET)을 수행해 EIP 레지스터의 값을 간접적으로 지정할 수 있다.
설명이 좀 그래서 따로 찾아본 내용도 적어둔다. EIP는 Extended Instruction Pointer니까, 아마 x86에서 쓰는 Instruction Pointer를 지칭할것이다.

레지스터의 구조를 알아야 하는 이유는, 버퍼 오버플로우 공격을 할 떄 적절한 padding의 사용과 return address의 정확한 위치를 찾고 assembly 코드를 추출하고 이해하는데 필요하다. 레지스터의 명령어 하나하나까지 머릿속에 저장하고 다니는건 정신병을 유발할 수 있으니, 그냥 머리속에 프레임만 넣어두고 필요한 것들은 이 문서를 참조하거나 검색을 통해 찾도록 하자.

이제 프로그램이 구동될때 Segment에서 어떤 일이 일어나는지 알아보자. 프로그램이 실행되면 프로세스가 메모리에 적재된다. 이들이 작동하는 원리를 알기 위해 간단한 프로그램을 예시로 들었고, 이를 어셈블리 코드로 변환해 컴파일 하는 과정이 나와있다. 어셈블리 코드는 컴파일러 버전 별로, 아키텍쳐 별로 달라지게 된다. 그러니까 다르더라도 너무 신경쓰지 말자. 좋고 나쁘고 자시고 한건 없다. 일단 다르면 짜증나니까 문서 기본세팅 보고 따라간다.
