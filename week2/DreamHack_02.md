지난 문서에서 간단하게 언급하고 넘어갔던 Memory Corruption 취약점들에 대해 좀 더 이야기를 해보자.

우선 가장 유명하고 오래된 취약점 중 하나인 버퍼 오버플로우다. 얼마나 유명한지 스택 오버플로우라는 이름의 외국 개발자 포럼도 있다.
C언어에서 버퍼는 “지정된 크기의 메모리 공간”이라는 의미이다. 버퍼 오버플로우는 버퍼가 허용할 수 있는 양의 데이터보다 더 많은 값이 저장되어 버퍼가 “넘치는” 취약점이다.
버퍼 오버플로우는 인접한 메모리를 오염시키기 떄문에 어떤 메모리를 오염시킬 수 있는지에 따라 공격 방법이 달라지고, 따라서 오염이 발생하는 위치에 따라 스택 버퍼 오버플로우, 힙 오버플로우 등으로 나눠 부른다.

스택 오버플로우는 가장 초기에 연구되었던 형태의 버퍼 오버플로우이고, 지역 변수가 할당되는 “스택 메모리”에서 오버플로우가 발생한 경우이다.
8바이트의 버퍼 A와 8바이트 데이터 버퍼 B가 메모리에 선천적으로 할당되었다고 생각해보자. 여기서 버퍼 A에 16바이트에 데이터를 복사하게 되면 데이터의 뒷부분이 버퍼A를 넘어 버퍼 B를 침범해 작성된다.
이때 우리는 버퍼 오버플로우가 발생했다고 하고, 이는 프로그램의 Undefined Behavior, 정의되지 않은 동작을 일으키게 되고 이는 어떠한 현상이 발생하는지 예측할 수 없게 한다. 만약 데이터 영역 B에 나중에 호출될 함수 포인터가 저장되어 있었다면 버퍼 오버플로우가 발생했을때 Segmentation Fault, 접근 권한이 없는 메모리를 사용하고자 할 때 발생하는 예외가 발생하게 된다. 공격자는 이를 악용해 함수 포인터를 공격자의 코드와 주소로 덮어 코드를 실행할 수 있다.


첫번째 예시를 살펴보자.
Gets 함수는 사용자로부터 데이터를 입력 받는 함수인데, 사용자가 입력한 데이터를 첫번째 인자로 전달된 버퍼에 저장한다. 이때 별도의 길이 제한이 없고 버퍼 길이에 대한 검증을 하지 않기 때문에 버퍼 크기보다 큰 데이터를 입력한다면 스택 버퍼 오버플로우가 발생한다.
이처럼 버퍼 오버플로우 취약점은 버퍼의 길이에 대한 가정을 올바르게 하지 않아 발생한다. 길이 제한이 없는 API 함수를 사용하거나 버퍼의 크기보다 입력받는 데이터가 더 크게 될떄 사용된다.

![](./img/2-01.png)


![](./img/2-02.png)

두번째 예시로 넘어가자. 두번째 예시의 main 함수는 argv[1]을 check 함수로 쩐달하고, 그 리턴값을 받아온다. 이때, 리턴값이 1이라면 정상적으로 작동하고, 0이라면 접근이 제한된다고 할 수 있다.
핵심이 되는 check 함수에서 16바이트 크기의 버퍼는 인자로 받은 패스워드를 복사하고,  비밀번호를 확인하고 문자열이 같다면 1을 리턴한다.
이때, 패스를 복사하는 과정에서 버퍼의 크기인 16바이트가 아닌 패스워드의 길이만큼 데이터를 복사하게 되고, 16바이트보다 더 큰 데이터를 입력받았을 때 스택 버퍼 오버플로우가 발생하게 된다.
메인에서 인증 결과를 전달하기 위한 auth 변수가 버퍼 뒤에 존재하므로 오버플로우를 통해 공격자가 auth 변수를 참으로 임의로 조작할 수 있게 되고, 이를 통해 실제 인증 여부와 상관없이 인증이 승인되게 된다.

![](./img/2-03.png)


![](./img/2-04.png)

세번째 예시는 버퍼에 24바이트 크기를 할당한다. scanf를 통해 문자열 크기를 입력받고, 문자열 크기만큼 데이터를 입력받는다. 이때 버퍼보다 큰 사이즈를 입력받을 수 있게 되고, 버퍼 오버플로우가 발생한다.

![](./img/2-05.png)


네번째 예시는 버퍼에 32바이트 크기를 부여하고 초기화한 후, 31바이트의 데이터를 입력받는다. sprintf함수를 통해 출력할 문자열을 저장한 뒤 출력하게된다. 
이때 입력받는 데이터가 32바이트를 넘진 않지만, sprintf 함수에서 문자열이 추가되며, 이를 포함했을 때 32바이트를 넘을 수 있게 되고, 버퍼를 가득 채웠을 때 스택 버퍼 오버플로우가 발생하게 된다.

![](./img/2-06.png)

이러한 예시들은 모두 프로그램을 설계하는 과정에서 입력받는 데이터에 길이에 대한 “검증”이 정확하지 못해 발생하게 된다. 만약 공격 벡터로부터 데이터를 입력받고 버퍼에 저장하게 된다면, 이를 유심히 살펴보아야 한다. 데이터를 버퍼에 입력받을 때 버퍼의 범위를 초과하지 않는지 항상 정확히 검사해야 한다.
입력받을 때 길이 제한이 없는 함수를 사용하면 잠재적인 취약점이 될 수 있다. 입력받은 데이터가 버퍼에 저장되기까지 흐름을 통해 버퍼의 크기를 넘는 양을 저장할 수 있는 가능성을 검토해야하고, 길이 제한이 있다면 명시된 길이가 버퍼의 크기를 넘을 수 있는지 검토해야 한다.

버퍼 오버플로우는 스택뿐 아니라 프로그래머가 동적으로 메모리를 관리하는 힙에서도 발생하고, 메모리 영역의 차이만 있는데, 사용 목적과 스택 영역이 다르기 대문에 다른 방법으로 익스플로잇 해야하므로, 여기서는 간단히 넘어간다. 

첫번째 예시는 40바이트 크기의 힙 버퍼 2개를 할당하고, 두번쩨 버퍼에는 Hi 문자열을 복사하고 첫번째 버퍼에 입력을 받는 것이다. 이때 입력 받는 데이터 길이가 버퍼의 크기보다 크게 되어 힙 오버플로우가 발생하게 된다. 첫번째 버퍼 영역에서 버퍼 오버플로우가 발생해 두번째 버퍼 영역에 침범할 경우, 복제된 “Hi” 문자열이 아닌 오염된 문자열이 출력되게 된다.

버퍼 오버플로우는 이정도이다. 이제 OOB 취약점으로 넘어가자. OOB, Out Of Boundary는 버퍼의 길이 범위를 벗어나는 인덱스에 접근할 때 발생하는 취약점이다. 
첫번째 예시에서는 int형 배열을 선언하고, 인덱스값을 입력받는다. 그 다음 입력받은 인덱스값의 배열에 정수를 입력하고 인덱스와 버퍼에 입력받은 입력값을 출력한다.
배열의 길이는 10이므로 인덱스는 0 이상 10 미만이어야 하지만, 인덱스를 입력받을 때 이를 검증하지 않고, c는 인덱스를 이용할 때 별도의 경계 검사가 존재하지 않기 때문에 인덱스 입력에 올바르지 않은 값을 사용해 배열 밖의 데이터값에 접근할 수 있다.

![](./img/2-07.png)

oob의 발생 여부를 판단할 때는 버퍼의 인덱스로 사용할 수 있는 값과 버퍼의 인덱스로 입력될 수 있는 모든 값의 범위를 비교하면 된다. 인덱스로 사용할 수 있는 값의 범위의 부분집합이 입력될 수 있는 모든 값이 된다면 안전하다고 할 수 있을 것이다.

두번째 예시는 인덱스 값으로 입력받은 값을 10으로 나눈 나머지를 사용하는데 양수만 고려했을때는 안전해 보이지만, 음수에 대한 검증을 하지 않는다. 따라서 나머지가 음수가 되게 한다면 Oob가 발생할 수 있다.

![](./img/2-08.png)

세번째 예시는 입력받은 인덱스를 양수로 바꿔줄 수 있는 코드까지 추가되었고, 아무 문제가 없어보인다. 하지만 이때는 int가 받을 수 있는 수의 범위에서 문제가 생긴다. int는 양수 2^31-1까지 표현 가능한데, 이때 2^31은 음에서만 표현 가능한다. 따라서 2^31을 인덱스에 입력하면, 절대값을 구하는 연산을 수행한 후에도 그대로 2^31이 저장되고, 이에 따라 음수가 저장되며 OOB가 발생하게 된다.
근본적인 해결책은 부호 정보 없이 양수만 저장하는 unsigned int형으로 선언하거나, 인덱스 입력 후 경계 검사 구문을 추가해야 한다.

Off-by-one 취약점으로 넘어가자. 경계 검사에서 하나의 오차가 있을때 발생하게 된다. 이는 버퍼 경계 계산 혹은 반복문의 횟수 계산시 포함 관계를 잘못 생각하거나, 0부터 시작하는 인덱스를 고려하지 않아 발생한다. 
주어진 예시의 경우 배열에 16바이트 문자열을 입력받은 후 복사하는 함수를 통해 배열과 배열의 크기를 넘겨주었는데, 반복 구간을 [0, sz)가 아닌 [0,sz]로 설정해 총 sz+1회의 복제가 이루어지게 된다. 따라서 off-by-one 취약점이 발생하게 된다.

![](./img/2-09.png)

![](./img/2-10.png)

버퍼 오버플로우 중 스택 버퍼 오버플로우는 지역 변수가 할당되는 스택 메모리에서 발생하고, 데이터를 입력받거나 복사하는 과정에서 검증이 없을때 발생한다.

힙 버퍼 오버플로우는 동적으로 할당된 힙 메모리 영역에서 발생한다. 데이터를 입력받거나 복사할 때 길이 검증이 완벽하지 않으면 발생한다.

OOB는 버퍼 길이 범위를 벗어나는 인덱스에 접근할 때 발생한다. 올바르지 않은 값이 인덱스로 사용될 수 있을 때 발생한다.

Off-By-One은 버퍼의 경계를 잘못 계산하거나 잘못된 반복문의 연산자를 사용하여 발생하게 된다.
